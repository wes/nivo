{"version":3,"file":"nivo-parallel-coordinates.es.js","sources":["../src/ParallelCoordinatesLineTooltip.tsx","../src/defaults.ts","../src/hooks.ts","../src/svg/ParallelCoordinatesLine.tsx","../src/svg/ParallelCoordinates.tsx","../src/svg/ResponsiveParallelCoordinates.tsx","../src/canvas/ParallelCoordinatesCanvas.tsx","../src/canvas/ResponsiveParallelCoordinatesCanvas.tsx"],"sourcesContent":["import { TableTooltip } from '@nivo/tooltip'\nimport { BaseDatum, TooltipProps, DatumGroupKeys } from './types'\n\nexport const ParallelCoordinatesLineTooltip = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    datum,\n    variables,\n}: TooltipProps<Datum, GroupBy>) => {\n    return (\n        <TableTooltip\n            rows={variables.map(variable => [\n                variable.label || variable.id,\n                <strong>{datum.data[variable.value] as number}</strong>, // eslint-disable-line react/jsx-key\n            ])}\n        />\n    )\n}\n","import { CommonProps, BaseDatum, LayerId } from './types'\nimport { ParallelCoordinatesLineTooltip } from './ParallelCoordinatesLineTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonProps<BaseDatum>,\n    | 'groupBy'\n    | 'groups'\n    | 'margin'\n    | 'theme'\n    | 'forwardLegendData'\n    | 'renderWrapper'\n    | 'ariaLabel'\n    | 'ariaLabelledBy'\n    | 'ariaDescribedBy'\n> = {\n    layout: 'horizontal',\n    curve: 'linear',\n\n    role: 'img',\n\n    colors: { scheme: 'category10' },\n    lineWidth: 2,\n    lineOpacity: 0.5,\n\n    axesTicksPosition: 'after',\n\n    isInteractive: true,\n    tooltip: ParallelCoordinatesLineTooltip,\n\n    legends: [],\n\n    animate: true,\n    motionConfig: 'gentle',\n}\n\nexport const svgDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n}\n\nexport const canvasDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1,\n}\n","import { useMemo, useRef, useEffect } from 'react'\nimport { line } from 'd3-shape'\nimport { scaleLinear, scalePoint } from 'd3-scale'\nimport { curveFromProp } from '@nivo/core'\nimport { OrdinalColorScaleConfig, useOrdinalColorScale } from '@nivo/colors'\nimport { castPointScale, castLinearScale, ScalePoint } from '@nivo/scales'\nimport {\n    Variable,\n    VariableWithScale,\n    CommonProps,\n    ComputedDatum,\n    BaseDatum,\n    BaseGroup,\n    Group,\n    CustomLayerProps,\n    GroupLegend,\n    DatumLegend,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from './types'\nimport { commonDefaultProps } from './defaults'\n\n/**\n * Compute groups.\n *\n * Please note that we assume that `groupBy` is defined, and correct, at this stage.\n *\n * If `predefinedGroups` is provided, we'll use it as a base, otherwise\n * we're going to scan each datum and extract their group, and then\n * make those unique to define the available groups.\n */\nconst computeGroups = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    predefinedGroups,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy: DatumGroupKeys<Datum>\n    predefinedGroups?: readonly BaseGroup[]\n    getColor: (group: BaseGroup) => string\n}): Group[] => {\n    let groups: Group[]\n\n    if (predefinedGroups !== undefined) {\n        groups = predefinedGroups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: getColor(group),\n        }))\n    } else {\n        const groupsSet = new Set<string>()\n        for (const datum of data) {\n            groupsSet.add(datum[groupBy] as string)\n        }\n\n        groups = Array.from(groupsSet, groupId => {\n            const group: BaseGroup = {\n                id: groupId,\n                label: groupId,\n            }\n\n            return {\n                ...group,\n                color: getColor(group),\n            }\n        })\n    }\n\n    return groups\n}\n\n/**\n * Compute the scale for each variable.\n *\n * We only support linear scales.\n *\n * Each scale domain will be computed automatically if `min`/`max` = `'auto'`,\n * otherwise, we'll use the provided values.\n */\nconst computeVariablesScales = <Datum extends BaseDatum>({\n    width,\n    height,\n    data,\n    variables,\n    layout,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    layout: CommonProps<Datum>['layout']\n}): readonly VariableWithScale<Datum>[] => {\n    // Depending on the layout, the range might need to be switched.\n    const range = layout === 'horizontal' ? [height, 0] : [0, width]\n\n    return variables.map(variable => {\n        const allValues: number[] = data.map(datum => datum[variable.value] as number)\n\n        const min =\n            variable.min !== undefined && variable.min !== 'auto'\n                ? variable.min\n                : Math.min(...allValues!)\n        const max =\n            variable.max !== undefined && variable.max !== 'auto'\n                ? variable.max\n                : Math.max(...allValues!)\n\n        const scale = castLinearScale(scaleLinear().rangeRound(range).domain([min, max]))\n\n        return { ...variable, scale }\n    })\n}\n\nconst computeDataVariables = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    groups,\n    variablesScale,\n    variablesWithScale,\n    layout,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy?: DatumGroupKeys<Datum>\n    groups: Group[] | undefined\n    variablesScale: ScalePoint<string>\n    variablesWithScale: readonly VariableWithScale<Datum>[]\n    layout: CommonProps<Datum>['layout']\n    getColor: (datum: Datum) => string\n}): ComputedDatum<Datum>[] | ComputedGroupDatum<Datum>[] => {\n    return data.map((datum, index) => {\n        const points: [number, number][] = variablesWithScale.map(variable => [\n            layout === 'horizontal'\n                ? variablesScale(variable.id)!\n                : variable.scale(datum[variable.value] as number),\n            layout === 'horizontal'\n                ? variable.scale(datum[variable.value] as number)\n                : variablesScale(variable.id)!,\n        ])\n\n        let group: Group | undefined = undefined\n        if (groupBy !== undefined) {\n            const datumGroup = datum[groupBy]\n            group = groups?.find(candidateGroup => candidateGroup.id === datumGroup)\n        }\n\n        const computedDatum: ComputedDatum<Datum> = {\n            id: datum.id,\n            index,\n            points,\n            data: datum,\n            color: group ? group.color : getColor(datum),\n        }\n\n        if (!group) return computedDatum\n\n        return {\n            ...computedDatum,\n            group,\n        } as ComputedGroupDatum<Datum>\n    })\n}\n\nexport const useParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    width,\n    height,\n    data,\n    variables,\n    groupBy,\n    groups: predefinedGroups,\n    layout = commonDefaultProps.layout,\n    curve = commonDefaultProps.curve,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<\n        IfGrouped<Datum, GroupBy, BaseGroup, Datum>\n    >,\n    forwardLegendData,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    groupBy?: CommonProps<Datum, GroupBy>['groupBy']\n    groups?: CommonProps<Datum, GroupBy>['groups']\n    layout: CommonProps<Datum, GroupBy>['layout']\n    curve: CommonProps<Datum, GroupBy>['curve']\n    colors: CommonProps<Datum, GroupBy>['colors']\n    forwardLegendData?: CommonProps<Datum, GroupBy>['forwardLegendData']\n}) => {\n    // If no groups, we'll use the data to define the color, otherwise the groups,\n    // meaning that `id` refers to either `Datum.id` or `Group.id`.\n    const getColor = useOrdinalColorScale(colors, 'id')\n\n    const groups = useMemo(() => {\n        if (groupBy === undefined) return undefined\n\n        return computeGroups<Datum>({\n            data,\n            groupBy,\n            predefinedGroups,\n            getColor: getColor as (group: BaseGroup) => string,\n        })\n    }, [data, groupBy, predefinedGroups, getColor])\n\n    const variablesScale = useMemo(() => {\n        const variableIds = variables.map(({ id }) => id)\n        return castPointScale(\n            scalePoint()\n                .range(layout === 'horizontal' ? [0, width] : [height, 0])\n                .domain(variableIds)\n        )\n    }, [variables, layout, width, height])\n\n    const variablesWithScale = useMemo(\n        () =>\n            computeVariablesScales<Datum>({\n                width,\n                height,\n                data,\n                variables,\n                layout,\n            }),\n        [width, height, data, variables, layout]\n    )\n\n    const computedData = useMemo(\n        () =>\n            computeDataVariables<Datum>({\n                data,\n                groupBy,\n                groups,\n                variablesScale,\n                variablesWithScale,\n                layout,\n                getColor,\n            }),\n        [data, groupBy, groups, variablesScale, variablesWithScale, layout, getColor]\n    )\n\n    const legendData = useMemo(() => {\n        if (!groups) {\n            return computedData.map(datum => ({\n                id: datum.id,\n                label: datum.id,\n                color: datum.color,\n                data: datum,\n            })) as DatumLegend<Datum>[]\n        }\n\n        return groups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: group.color,\n            data: group,\n        })) as GroupLegend[]\n    }, [groups, computedData])\n\n    // Forward the legends data if `forwardLegendData` is defined.\n    const forwardLegendDataRef = useRef(forwardLegendData)\n    useEffect(() => {\n        if (typeof forwardLegendDataRef.current !== 'function') return\n        forwardLegendDataRef.current(\n            legendData as IfGrouped<Datum, GroupBy, GroupLegend[], DatumLegend<Datum>[]>\n        )\n    }, [forwardLegendDataRef, legendData])\n\n    const lineGenerator = useMemo(\n        () => line<[number, number]>().curve(curveFromProp(curve)),\n        [curve]\n    )\n\n    const customLayerContext: CustomLayerProps<Datum> = useMemo(\n        () => ({\n            computedData,\n            variables,\n            lineGenerator,\n        }),\n        [computedData, variables, lineGenerator]\n    )\n\n    return {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    }\n}\n","import { useCallback, MouseEvent, createElement } from 'react'\nimport { Line } from 'd3-shape'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport {\n    BaseDatum,\n    ComputedDatum,\n    Variable,\n    TooltipComponent,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from '../types'\n\nexport const ParallelCoordinatesLine = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    datum,\n    variables,\n    lineGenerator,\n    lineWidth,\n    opacity,\n    tooltip,\n    testIdPrefix,\n}: {\n    datum: IfGrouped<Datum, GroupBy, ComputedGroupDatum<Datum>, ComputedDatum<Datum>>\n    variables: readonly Variable<Datum>[]\n    lineGenerator: Line<[number, number]>\n    lineWidth: number\n    opacity: number\n    tooltip: TooltipComponent<Datum, GroupBy>\n    testIdPrefix?: string\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { datum, variables }), event)\n        },\n        [showTooltipFromEvent, datum, variables]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(lineGenerator(datum.points)!)\n    const animatedProps = useSpring({\n        color: datum.color,\n        opacity,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            stroke={animatedProps.color}\n            strokeWidth={lineWidth}\n            strokeLinecap=\"round\"\n            opacity={animatedProps.opacity}\n            fill=\"none\"\n            onMouseEnter={handleMouseHover}\n            onMouseMove={handleMouseHover}\n            onMouseLeave={hideTooltip}\n            data-test-id={testIdPrefix ? `${testIdPrefix}.line_${datum.id}` : undefined}\n        />\n    )\n}\n","import { createElement, Fragment, ReactNode } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { Axis } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { svgDefaultProps } from '../defaults'\nimport { useParallelCoordinates } from '../hooks'\nimport {\n    ParallelCoordinatesProps,\n    BaseDatum,\n    LayerId,\n    DatumGroupKeys,\n    TooltipComponent,\n    IfGrouped,\n    ComputedGroupDatum,\n    ComputedDatum,\n} from '../types'\nimport { ParallelCoordinatesLine } from './ParallelCoordinatesLine'\n\ntype InnerParallelCoordinatesProps<\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n> = Omit<\n    ParallelCoordinatesProps<Datum, GroupBy>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    data,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    layout = svgDefaultProps.layout,\n    curve = svgDefaultProps.curve,\n    axesTicksPosition,\n    lineWidth = svgDefaultProps.lineWidth,\n    lineOpacity = svgDefaultProps.lineOpacity,\n    colors = svgDefaultProps.colors,\n    layers = svgDefaultProps.layers,\n    tooltip = svgDefaultProps.tooltip as unknown as TooltipComponent<Datum, GroupBy>,\n    legends = svgDefaultProps.legends,\n    forwardLegendData,\n    role = svgDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    testIdPrefix,\n}: InnerParallelCoordinatesProps<Datum, GroupBy>) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<Datum, GroupBy>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const layerById: Record<LayerId, ReactNode> = {\n        axes: null,\n        lines: null,\n        legends: null,\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <g key=\"axes\">\n                {variablesWithScale.map(variable => (\n                    <Axis\n                        key={variable.id}\n                        axis={layout === 'horizontal' ? 'y' : 'x'}\n                        length={layout === 'horizontal' ? innerHeight : innerWidth}\n                        x={layout === 'horizontal' ? variablesScale(variable.id) : 0}\n                        y={layout === 'horizontal' ? 0 : variablesScale(variable.id)}\n                        scale={variable.scale}\n                        ticksPosition={variable.ticksPosition || axesTicksPosition}\n                        tickValues={variable.tickValues}\n                        tickSize={variable.tickSize}\n                        tickPadding={variable.tickPadding}\n                        tickRotation={variable.tickRotation}\n                        format={variable.tickFormat}\n                        legend={variable.label || variable.id}\n                        legendPosition={variable.legendPosition}\n                        legendOffset={variable.legendOffset}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <g key=\"lines\">\n                {computedData.map(datum => (\n                    <ParallelCoordinatesLine<Datum, GroupBy>\n                        key={`${'group' in datum ? datum.group.id : ''}${datum.id}`}\n                        datum={\n                            datum as IfGrouped<\n                                Datum,\n                                GroupBy,\n                                ComputedGroupDatum<Datum>,\n                                ComputedDatum<Datum>\n                            >\n                        }\n                        variables={variables}\n                        lineGenerator={lineGenerator}\n                        lineWidth={lineWidth}\n                        opacity={lineOpacity}\n                        tooltip={tooltip}\n                        testIdPrefix={testIdPrefix}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <g key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legendData}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, customLayerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const ParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesProps<Datum, GroupBy>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerParallelCoordinates<Datum, GroupBy> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { ParallelCoordinatesProps, BaseDatum, DatumGroupKeys } from '../types'\nimport { ParallelCoordinates } from './ParallelCoordinates'\n\nexport const ResponsiveParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>(\n    props: Omit<ParallelCoordinatesProps<Datum, GroupBy>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinates<Datum, GroupBy> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import { useEffect, useRef } from 'react'\nimport { Container, useDimensions, useTheme } from '@nivo/core'\nimport { renderAxisToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useParallelCoordinates } from '../hooks'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { canvasDefaultProps } from '../defaults'\n\ntype InnerParallelCoordinatesCanvasProps<D extends BaseDatum> = Omit<\n    ParallelCoordinatesCanvasProps<D>,\n    'renderWrapper' | 'theme'\n>\n\nexport const InnerParallelCoordinatesCanvas = <D extends BaseDatum>({\n    data,\n    layout = canvasDefaultProps.layout,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    curve = canvasDefaultProps.curve,\n    colors = canvasDefaultProps.colors,\n    lineOpacity = canvasDefaultProps.lineOpacity,\n    lineWidth = canvasDefaultProps.lineWidth,\n    axesTicksPosition = canvasDefaultProps.axesTicksPosition,\n    legends = canvasDefaultProps.legends,\n    forwardLegendData,\n    layers = canvasDefaultProps.layers,\n    role = canvasDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n}: InnerParallelCoordinatesCanvasProps<D>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<D>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const theme = useTheme()\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        const ctx = canvasEl.current.getContext('2d')\n        if (ctx === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (layer === 'axes') {\n                variablesWithScale.forEach(variable => {\n                    renderAxisToCanvas(ctx, {\n                        axis: layout === 'horizontal' ? 'y' : 'x',\n                        scale: variable.scale,\n                        x: layout === 'horizontal' ? variablesScale(variable.id) : 0,\n                        y: layout === 'horizontal' ? 0 : variablesScale(variable.id),\n                        length: layout === 'horizontal' ? innerHeight : innerWidth,\n                        ticksPosition: axesTicksPosition,\n                        theme,\n                    })\n                })\n            } else if (layer === 'lines') {\n                lineGenerator.context(ctx)\n\n                computedData.forEach(datum => {\n                    ctx.save()\n                    ctx.globalAlpha = lineOpacity\n\n                    ctx.beginPath()\n                    lineGenerator(datum.points)\n                    ctx.strokeStyle = datum.color\n                    ctx.lineWidth = lineWidth\n                    ctx.stroke()\n\n                    ctx.restore()\n                })\n            } else if (layer === 'legends') {\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            } else if (typeof layer === 'function') {\n                layer(ctx, customLayerContext)\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        innerWidth,\n        innerHeight,\n        margin,\n        layers,\n        customLayerContext,\n        lineGenerator,\n        lineOpacity,\n        lineWidth,\n        computedData,\n        variablesScale,\n        variablesWithScale,\n        layout,\n        axesTicksPosition,\n        legends,\n        legendData,\n        theme,\n        pixelRatio,\n    ])\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n            }}\n            role={role}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledBy}\n            aria-describedby={ariaDescribedBy}\n        />\n    )\n}\n\nexport const ParallelCoordinatesCanvas = <D extends BaseDatum>({\n    theme,\n    isInteractive = canvasDefaultProps.isInteractive,\n    animate = canvasDefaultProps.animate,\n    motionConfig = canvasDefaultProps.motionConfig,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesCanvasProps<D>) => (\n    <Container {...{ isInteractive, animate, motionConfig, theme, renderWrapper }}>\n        <InnerParallelCoordinatesCanvas<D> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { ParallelCoordinatesCanvas } from './ParallelCoordinatesCanvas'\n\nexport const ResponsiveParallelCoordinatesCanvas = <D extends BaseDatum>(\n    props: Omit<ParallelCoordinatesCanvasProps<D>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinatesCanvas<D> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n"],"names":["commonDefaultProps","layout","curve","role","colors","scheme","lineWidth","lineOpacity","axesTicksPosition","isInteractive","tooltip","_ref","datum","variables","_jsx","TableTooltip","rows","map","variable","label","id","children","data","value","legends","animate","motionConfig","svgDefaultProps","_extends","layers","canvasDefaultProps","pixelRatio","window","_window$devicePixelRa","devicePixelRatio","useParallelCoordinates","_ref4","width","height","groupBy","predefinedGroups","groups","_ref4$layout","_ref4$curve","_ref4$colors","forwardLegendData","getColor","useOrdinalColorScale","useMemo","undefined","group","color","_step","groupsSet","Set","_iterator","_createForOfIteratorHelperLoose","done","add","Array","from","groupId","computeGroups","variablesScale","variableIds","_ref5","castPointScale","scalePoint","range","domain","variablesWithScale","_ref2","allValues","min","Math","apply","max","scale","castLinearScale","scaleLinear","rangeRound","computeVariablesScales","computedData","_ref3","index","points","datumGroup","find","candidateGroup","computedDatum","computeDataVariables","legendData","forwardLegendDataRef","useRef","useEffect","current","lineGenerator","line","curveFromProp","customLayerContext","ParallelCoordinatesLine","opacity","testIdPrefix","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseHover","useCallback","event","createElement","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","path","d","stroke","strokeWidth","strokeLinecap","fill","onMouseEnter","onMouseMove","onMouseLeave","InnerParallelCoordinates","partialMargin","margin","_ref$layout","_ref$curve","_ref$lineWidth","_ref$lineOpacity","_ref$colors","_ref$layers","_ref$tooltip","_ref$legends","_ref$role","ariaLabel","ariaLabelledBy","ariaDescribedBy","_useDimensions","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","_useParallelCoordinat","layerById","axes","lines","includes","Axis","axis","length","x","y","ticksPosition","tickValues","tickSize","tickPadding","tickRotation","format","tickFormat","legend","legendPosition","legendOffset","i","BoxLegendSvg","containerWidth","containerHeight","SvgWrapper","layer","_layerById$layer","Fragment","ParallelCoordinates","_ref2$isInteractive","_ref2$animate","_ref2$motionConfig","theme","renderWrapper","otherProps","_objectWithoutPropertiesLoose","_excluded","Container","ResponsiveParallelCoordinates","props","ResponsiveWrapper","InnerParallelCoordinatesCanvas","_ref$axesTicksPositio","_ref$pixelRatio","canvasEl","useTheme","ctx","getContext","fillStyle","background","fillRect","translate","left","top","forEach","renderAxisToCanvas","context","save","globalAlpha","beginPath","strokeStyle","restore","renderLegendToCanvas","ref","style","ParallelCoordinatesCanvas","ResponsiveParallelCoordinatesCanvas"],"mappings":"y6DAGO,MCAMA,EAWT,CACAC,OAAQ,aACRC,MAAO,SAEPC,KAAM,MAENC,OAAQ,CAAEC,OAAQ,cAClBC,UAAW,EACXC,YAAa,GAEbC,kBAAmB,QAEnBC,eAAe,EACfC,QDxB0C,SAAHC,GAMP,IAFhCC,EAAKD,EAALC,MACAC,EAASF,EAATE,UAEA,OACIC,EAACC,EAAY,CACTC,KAAMH,EAAUI,KAAI,SAAAC,GAAQ,MAAI,CAC5BA,EAASC,OAASD,EAASE,GAC3BN,EAAA,SAAA,CAAAO,SAAST,EAAMU,KAAKJ,EAASK,SAChC,KAGb,ECWIC,QAAS,GAETC,SAAS,EACTC,aAAc,UAGLC,EAAeC,KACrB5B,EAAkB,CACrB6B,OAAQ,CAAC,QAAS,OAAQ,aAGjBC,EAAkBF,KACxB5B,EAAkB,CACrB6B,OAAQ,CAAC,QAAS,OAAQ,WAC1BE,WAA8B,oBAAXC,QAAgD,OAA1BC,EAAGD,OAAOE,kBAAgBD,EAAQ,IC0HlEE,EAAyB,SAAHC,GA2B7B,IAvBFC,EAAKD,EAALC,MACAC,EAAMF,EAANE,OACAhB,EAAIc,EAAJd,KACAT,EAASuB,EAATvB,UACA0B,EAAOH,EAAPG,QACQC,EAAgBJ,EAAxBK,OAAMC,EAAAN,EACNnC,OAAAA,OAAM,IAAAyC,EAAG1C,EAAmBC,OAAMyC,EAAAC,EAAAP,EAClClC,MAAAA,OAAK,IAAAyC,EAAG3C,EAAmBE,MAAKyC,EAAAC,EAAAR,EAChChC,OAAAA,OAAM,IAAAwC,EAAG5C,EAAmBI,OAAMwC,EAGlCC,EAAiBT,EAAjBS,kBAeMC,EAAWC,EAAqB3C,EAAQ,MAExCqC,EAASO,GAAQ,WACnB,QAAgBC,IAAZV,EAEJ,OAxKc,SAAH5B,GAUJ,IACP8B,EAVJnB,EAAIX,EAAJW,KACAiB,EAAO5B,EAAP4B,QACAC,EAAgB7B,EAAhB6B,iBACAM,EAAQnC,EAARmC,SASA,QAAyBG,IAArBT,EACAC,EAASD,EAAiBvB,KAAI,SAAAiC,GAAK,MAAK,CACpC9B,GAAI8B,EAAM9B,GACVD,MAAO+B,EAAM/B,OAAS+B,EAAM9B,GAC5B+B,MAAOL,EAASI,GACnB,QACE,CAEH,IADA,IACwBE,EADlBC,EAAY,IAAIC,IACtBC,EAAAC,EAAoBlC,KAAI8B,EAAAG,KAAAE,MAAE,CAAA,IAAf7C,EAAKwC,EAAA7B,MACZ8B,EAAUK,IAAI9C,EAAM2B,GACxB,CAEAE,EAASkB,MAAMC,KAAKP,GAAW,SAAAQ,GAC3B,IAAMX,EAAmB,CACrB9B,GAAIyC,EACJ1C,MAAO0C,GAGX,OAAAjC,KACOsB,EAAK,CACRC,MAAOL,EAASI,IAExB,GACJ,CAEA,OAAOT,CACX,CAiIeqB,CAAqB,CACxBxC,KAAAA,EACAiB,QAAAA,EACAC,iBAAAA,EACAM,SAAUA,GAEjB,GAAE,CAACxB,EAAMiB,EAASC,EAAkBM,IAE/BiB,EAAiBf,GAAQ,WAC3B,IAAMgB,EAAcnD,EAAUI,KAAI,SAAAgD,GAAK,OAAAA,EAAF7C,MACrC,OAAO8C,EACHC,IACKC,MAAiB,eAAXnE,EAA0B,CAAC,EAAGoC,GAAS,CAACC,EAAQ,IACtD+B,OAAOL,GAEnB,GAAE,CAACnD,EAAWZ,EAAQoC,EAAOC,IAExBgC,EAAqBtB,GACvB,WAAA,OAzIuB,SAAHuB,GAYe,IAXvClC,EAAKkC,EAALlC,MACAC,EAAMiC,EAANjC,OACAhB,EAAIiD,EAAJjD,KACAT,EAAS0D,EAAT1D,UAUMuD,EAAmB,eATnBG,EAANtE,OASwC,CAACqC,EAAQ,GAAK,CAAC,EAAGD,GAE1D,OAAOxB,EAAUI,KAAI,SAAAC,GACjB,IAAMsD,EAAsBlD,EAAKL,KAAI,SAAAL,GAAK,OAAIA,EAAMM,EAASK,MAAM,IAE7DkD,OACexB,IAAjB/B,EAASuD,KAAsC,SAAjBvD,EAASuD,IACjCvD,EAASuD,IACTC,KAAKD,IAAGE,MAARD,KAAYF,GAChBI,OACe3B,IAAjB/B,EAAS0D,KAAsC,SAAjB1D,EAAS0D,IACjC1D,EAAS0D,IACTF,KAAKE,IAAGD,MAARD,KAAYF,GAEhBK,EAAQC,EAAgBC,IAAcC,WAAWZ,GAAOC,OAAO,CAACI,EAAKG,KAE3E,OAAAhD,KAAYV,EAAQ,CAAE2D,MAAAA,GAC1B,GACJ,CA0GYI,CAA8B,CAC1B5C,MAAAA,EACAC,OAAAA,EACAhB,KAAAA,EACAT,UAAAA,EACAZ,OAAAA,MAER,CAACoC,EAAOC,EAAQhB,EAAMT,EAAWZ,IAG/BiF,EAAelC,GACjB,WAAA,OAnHqB,SAAHmC,GAgBkC,IAfxD7D,EAAI6D,EAAJ7D,KACAiB,EAAO4C,EAAP5C,QACAE,EAAM0C,EAAN1C,OACAsB,EAAcoB,EAAdpB,eACAO,EAAkBa,EAAlBb,mBACArE,EAAMkF,EAANlF,OACA6C,EAAQqC,EAARrC,SAUA,OAAOxB,EAAKL,KAAI,SAACL,EAAOwE,GACpB,IAAMC,EAA6Bf,EAAmBrD,KAAI,SAAAC,GAAQ,MAAI,CACvD,eAAXjB,EACM8D,EAAe7C,EAASE,IACxBF,EAAS2D,MAAMjE,EAAMM,EAASK,QACzB,eAAXtB,EACMiB,EAAS2D,MAAMjE,EAAMM,EAASK,QAC9BwC,EAAe7C,EAASE,QAG9B8B,OAA2BD,EAC/B,QAAgBA,IAAZV,EAAuB,CACvB,IAAM+C,EAAa1E,EAAM2B,GACzBW,EAAQT,MAAAA,OAAAA,EAAAA,EAAQ8C,MAAK,SAAAC,GAAc,OAAIA,EAAepE,KAAOkE,IACjE,CAEA,IAAMG,EAAsC,CACxCrE,GAAIR,EAAMQ,GACVgE,MAAAA,EACAC,OAAAA,EACA/D,KAAMV,EACNuC,MAAOD,EAAQA,EAAMC,MAAQL,EAASlC,IAG1C,OAAKsC,EAELtB,KACO6D,EAAa,CAChBvC,MAAAA,IAJeuC,CAMvB,GACJ,CAoEYC,CAA4B,CACxBpE,KAAAA,EACAiB,QAAAA,EACAE,OAAAA,EACAsB,eAAAA,EACAO,mBAAAA,EACArE,OAAAA,EACA6C,SAAAA,GACF,GACN,CAACxB,EAAMiB,EAASE,EAAQsB,EAAgBO,EAAoBrE,EAAQ6C,IAGlE6C,EAAa3C,GAAQ,WACvB,OAAKP,EASEA,EAAOxB,KAAI,SAAAiC,GAAK,MAAK,CACxB9B,GAAI8B,EAAM9B,GACVD,MAAO+B,EAAM/B,OAAS+B,EAAM9B,GAC5B+B,MAAOD,EAAMC,MACb7B,KAAM4B,EACT,IAbUgC,EAAajE,KAAI,SAAAL,GAAK,MAAK,CAC9BQ,GAAIR,EAAMQ,GACVD,MAAOP,EAAMQ,GACb+B,MAAOvC,EAAMuC,MACb7B,KAAMV,EACT,GAST,GAAG,CAAC6B,EAAQyC,IAGNU,EAAuBC,EAAOhD,GACpCiD,GAAU,WACsC,mBAAjCF,EAAqBG,SAChCH,EAAqBG,QACjBJ,EAER,GAAG,CAACC,EAAsBD,IAE1B,IAAMK,EAAgBhD,GAClB,WAAA,OAAMiD,IAAyB/F,MAAMgG,EAAchG,MACnD,CAACA,IAGCiG,EAA8CnD,GAChD,WAAA,MAAO,CACHkC,aAAAA,EACArE,UAAAA,EACAmF,cAAAA,EACF,GACF,CAACd,EAAcrE,EAAWmF,IAG9B,MAAO,CACHjC,eAAAA,EACAO,mBAAAA,EACAY,aAAAA,EACAc,cAAAA,EACAL,WAAAA,EACAQ,mBAAAA,EAER,ECrRaC,EAA0B,SAAHzF,GAmB9B,IAfFC,EAAKD,EAALC,MACAC,EAASF,EAATE,UACAmF,EAAarF,EAAbqF,cACA1F,EAASK,EAATL,UACA+F,EAAO1F,EAAP0F,QACA3F,EAAOC,EAAPD,QACA4F,EAAY3F,EAAZ2F,aAUAC,EAA8CC,IAAtCC,EAAoBF,EAApBE,qBAAsBC,EAAWH,EAAXG,YACxBC,EAAmBC,GACrB,SAACC,GACGJ,EAAqBK,EAAcpG,EAAS,CAAEE,MAAAA,EAAOC,UAAAA,IAAcgG,EACtE,GACD,CAACJ,EAAsB7F,EAAOC,IAGlCkG,EAA0CC,IAAlCvF,EAAOsF,EAAPtF,QAAiBwF,EAAYF,EAApBG,OACXC,EAAeC,EAAgBpB,EAAcpF,EAAMyE,SACnDgC,EAAgBC,EAAU,CAC5BnE,MAAOvC,EAAMuC,MACbkD,QAAAA,EACAa,OAAQD,EACRM,WAAY9F,IAGhB,OACIX,EAAC0G,EAASC,KAAI,CACVC,EAAGP,EACHQ,OAAQN,EAAclE,MACtByE,YAAatH,EACbuH,cAAc,QACdxB,QAASgB,EAAchB,QACvByB,KAAK,OACLC,aAAcpB,EACdqB,YAAarB,EACbsB,aAAcvB,EACd,eAAcJ,EAAkBA,WAAqB1F,EAAMQ,QAAO6B,GAG9E,uECxCMiF,EAA2B,SAAHvH,GA0BuB,IAtBjDW,EAAIX,EAAJW,KACAT,EAASF,EAATE,UACA0B,EAAO5B,EAAP4B,QACAE,EAAM9B,EAAN8B,OACAJ,EAAK1B,EAAL0B,MACAC,EAAM3B,EAAN2B,OACQ6F,EAAaxH,EAArByH,OAAMC,EAAA1H,EACNV,OAAAA,OAAM,IAAAoI,EAAG1G,EAAgB1B,OAAMoI,EAAAC,EAAA3H,EAC/BT,MAAAA,OAAK,IAAAoI,EAAG3G,EAAgBzB,MAAKoI,EAC7B9H,EAAiBG,EAAjBH,kBAAiB+H,EAAA5H,EACjBL,UAAAA,OAAS,IAAAiI,EAAG5G,EAAgBrB,UAASiI,EAAAC,EAAA7H,EACrCJ,YAAAA,OAAW,IAAAiI,EAAG7G,EAAgBpB,YAAWiI,EAAAC,EAAA9H,EACzCP,OAAAA,OAAM,IAAAqI,EAAG9G,EAAgBvB,OAAMqI,EAAAC,EAAA/H,EAC/BkB,OAAAA,OAAM,IAAA6G,EAAG/G,EAAgBE,OAAM6G,EAAAC,EAAAhI,EAC/BD,QAAAA,OAAO,IAAAiI,EAAGhH,EAAgBjB,QAAOiI,EAAAC,EAAAjI,EACjCa,QAAAA,OAAO,IAAAoH,EAAGjH,EAAgBH,QAAOoH,EACjC/F,EAAiBlC,EAAjBkC,kBAAiBgG,EAAAlI,EACjBR,KAAAA,OAAI,IAAA0I,EAAGlH,EAAgBxB,KAAI0I,EAC3BC,EAASnI,EAATmI,UACAC,EAAcpI,EAAdoI,eACAC,EAAerI,EAAfqI,gBACA1C,EAAY3F,EAAZ2F,aAEA2C,EAAqEC,EACjE7G,EACAC,EACA6F,GAHIgB,EAAUF,EAAVE,WAAYC,EAAWH,EAAXG,YAAahB,EAAMa,EAANb,OAAQiB,EAAUJ,EAAVI,WAAYC,EAAWL,EAAXK,YAMrDC,EAOIpH,EAAuC,CACvCE,MAAOgH,EACP/G,OAAQgH,EACRhI,KAAAA,EACAT,UAAAA,EACA0B,QAAAA,EACAE,OAAAA,EACAxC,OAAAA,EACAG,OAAAA,EACAF,MAAAA,EACA2C,kBAAAA,IAhBAkB,EAAcwF,EAAdxF,eACAO,EAAkBiF,EAAlBjF,mBACAY,EAAYqE,EAAZrE,aACAc,EAAauD,EAAbvD,cACAL,GAAU4D,EAAV5D,WACAQ,GAAkBoD,EAAlBpD,mBAcEqD,GAAwC,CAC1CC,KAAM,KACNC,MAAO,KACPlI,QAAS,MAuEb,OApEIK,EAAO8H,SAAS,UAChBH,GAAUC,KACN3I,EAAA,IAAA,CAAAO,SACKiD,EAAmBrD,KAAI,SAAAC,GAAQ,OAC5BJ,EAAC8I,EAAI,CAEDC,KAAiB,eAAX5J,EAA0B,IAAM,IACtC6J,OAAmB,eAAX7J,EAA0BqJ,EAAcD,EAChDU,EAAc,eAAX9J,EAA0B8D,EAAe7C,EAASE,IAAM,EAC3D4I,EAAc,eAAX/J,EAA0B,EAAI8D,EAAe7C,EAASE,IACzDyD,MAAO3D,EAAS2D,MAChBoF,cAAe/I,EAAS+I,eAAiBzJ,EACzC0J,WAAYhJ,EAASgJ,WACrBC,SAAUjJ,EAASiJ,SACnBC,YAAalJ,EAASkJ,YACtBC,aAAcnJ,EAASmJ,aACvBC,OAAQpJ,EAASqJ,WACjBC,OAAQtJ,EAASC,OAASD,EAASE,GACnCqJ,eAAgBvJ,EAASuJ,eACzBC,aAAcxJ,EAASwJ,cAdlBxJ,EAASE,QAHnB,SAwBXS,EAAO8H,SAAS,WAChBH,GAAUE,MACN5I,EAAA,IAAA,CAAAO,SACK6D,EAAajE,KAAI,SAAAL,GAAK,OACnBE,EAACsF,EAAuB,CAEpBxF,MACIA,EAOJC,UAAWA,EACXmF,cAAeA,EACf1F,UAAWA,EACX+F,QAAS9F,EACTG,QAASA,EACT4F,aAAcA,GAAa,IAdnB,UAAW1F,EAAQA,EAAMsC,MAAM9B,GAAK,IAAKR,EAAMQ,QAH5D,UAwBXS,EAAO8H,SAAS,aAChBH,GAAUhI,QACNV,EAAA,IAAA,CAAAO,SACKG,EAAQP,KAAI,SAACuJ,EAAQG,GAAC,OACnB7J,EAAC8J,EAAYhJ,KAEL4I,EAAM,CACVK,eAAgBxB,EAChByB,gBAAiBxB,EACjBhI,KAAMqE,KAJDgF,OAHV,YAeX7J,EAACiK,EAAU,CACP1I,MAAO8G,EACP7G,OAAQ8G,EACRhB,OAAQA,EACRjI,KAAMA,EACN2I,UAAWA,EACXC,eAAgBA,EAChBC,gBAAiBA,EAAgB3H,SAEhCQ,EAAOZ,KAAI,SAAC+J,EAAOL,GAAM,IAAAM,EACtB,MAAqB,mBAAVD,EACAlK,EAACoK,EAAQ,CAAA7J,SAAUyF,EAAckE,EAAO7E,KAAzBwE,GAGD,OAAzBM,EAAOzB,MAAAA,QAAAA,EAAAA,GAAYwB,IAAMC,EAAI,SAI7C,EAEaE,EAAsB,SAAH5G,GAAA,IAAA6G,EAAA7G,EAI5B9D,cAAAA,OAAa,IAAA2K,EAAGzJ,EAAgBlB,cAAa2K,EAAAC,EAAA9G,EAC7C9C,QAAAA,OAAO,IAAA4J,EAAG1J,EAAgBF,QAAO4J,EAAAC,EAAA/G,EACjC7C,aAAAA,OAAY,IAAA4J,EAAG3J,EAAgBD,aAAY4J,EAC3CC,EAAKhH,EAALgH,MACAC,EAAajH,EAAbiH,cACGC,EAAUC,EAAAnH,EAAAoH,GAAA,OAEb7K,EAAC8K,EAAS,CAEFnK,QAAAA,EACAhB,cAAAA,EACAiB,aAAAA,EACA8J,cAAAA,EACAD,MAAAA,EAAKlK,SAGTP,EAACoH,EAAwBtG,EAAA,CAAiBnB,cAAeA,GAAmBgL,KACpE,EC/LHI,EAAgC,SAIzCC,GAAyE,OAEzEhL,EAACiL,EAAiB,CAAA1K,SACb,SAAAV,GAAA,IAAG0B,EAAK1B,EAAL0B,MAAOC,EAAM3B,EAAN2B,OAAM,OACbxB,EAACqK,EAAmBvJ,EAAA,CAAiBS,MAAOA,EAAOC,OAAQA,GAAYwJ,GAAS,GAEpE,uECDXE,EAAiC,SAAHrL,GAsBG,IArB1CW,EAAIX,EAAJW,KAAI+G,EAAA1H,EACJV,OAAAA,OAAM,IAAAoI,EAAGvG,EAAmB7B,OAAMoI,EAClCxH,EAASF,EAATE,UACA0B,EAAO5B,EAAP4B,QACAE,EAAM9B,EAAN8B,OACAJ,EAAK1B,EAAL0B,MACAC,EAAM3B,EAAN2B,OACQ6F,EAAaxH,EAArByH,OAAME,EAAA3H,EACNT,MAAAA,OAAK,IAAAoI,EAAGxG,EAAmB5B,MAAKoI,EAAAG,EAAA9H,EAChCP,OAAAA,OAAM,IAAAqI,EAAG3G,EAAmB1B,OAAMqI,EAAAD,EAAA7H,EAClCJ,YAAAA,OAAW,IAAAiI,EAAG1G,EAAmBvB,YAAWiI,EAAAD,EAAA5H,EAC5CL,UAAAA,OAAS,IAAAiI,EAAGzG,EAAmBxB,UAASiI,EAAA0D,EAAAtL,EACxCH,kBAAAA,OAAiB,IAAAyL,EAAGnK,EAAmBtB,kBAAiByL,EAAArD,EAAAjI,EACxDa,QAAAA,OAAO,IAAAoH,EAAG9G,EAAmBN,QAAOoH,EACpC/F,EAAiBlC,EAAjBkC,kBAAiB6F,EAAA/H,EACjBkB,OAAAA,OAAM,IAAA6G,EAAG5G,EAAmBD,OAAM6G,EAAAG,EAAAlI,EAClCR,KAAAA,OAAI,IAAA0I,EAAG/G,EAAmB3B,KAAI0I,EAC9BC,EAASnI,EAATmI,UACAC,EAAcpI,EAAdoI,eACAC,EAAerI,EAAfqI,gBAAekD,EAAAvL,EACfoB,WAAAA,OAAU,IAAAmK,EAAGpK,EAAmBC,WAAUmK,EAEpCC,EAAWtG,EAAiC,MAElDoD,EAAqEC,EACjE7G,EACAC,EACA6F,GAHIC,EAAMa,EAANb,OAAQiB,EAAUJ,EAAVI,WAAYC,EAAWL,EAAXK,YAAaH,EAAUF,EAAVE,WAAYC,EAAWH,EAAXG,YAMrDG,EAOIpH,EAA0B,CAC1BE,MAAOgH,EACP/G,OAAQgH,EACRhI,KAAAA,EACAT,UAAAA,EACA0B,QAAAA,EACAE,OAAAA,EACAxC,OAAAA,EACAG,OAAAA,EACAF,MAAAA,EACA2C,kBAAAA,IAhBAkB,EAAcwF,EAAdxF,eACAO,EAAkBiF,EAAlBjF,mBACAY,EAAYqE,EAAZrE,aACAc,EAAauD,EAAbvD,cACAL,GAAU4D,EAAV5D,WACAQ,GAAkBoD,EAAlBpD,mBAcEoF,GAAQa,IAkFd,OAhFAtG,GAAU,WACN,GAAyB,OAArBqG,EAASpG,QAAb,CAEA,IAAMsG,EAAMF,EAASpG,QAAQuG,WAAW,MAC5B,OAARD,IAEJF,EAASpG,QAAQ1D,MAAQ8G,EAAapH,EACtCoK,EAASpG,QAAQzD,OAAS8G,EAAcrH,EAExCsK,EAAIxH,MAAM9C,EAAYA,GAEtBsK,EAAIE,UAAYhB,GAAMiB,WACtBH,EAAII,SAAS,EAAG,EAAGtD,EAAYC,GAC/BiD,EAAIK,UAAUtE,EAAOuE,KAAMvE,EAAOwE,KAElC/K,EAAOgL,SAAQ,SAAA7B,GACG,SAAVA,EACA1G,EAAmBuI,SAAQ,SAAA3L,GACvB4L,EAAmBT,EAAK,CACpBxC,KAAiB,eAAX5J,EAA0B,IAAM,IACtC4E,MAAO3D,EAAS2D,MAChBkF,EAAc,eAAX9J,EAA0B8D,EAAe7C,EAASE,IAAM,EAC3D4I,EAAc,eAAX/J,EAA0B,EAAI8D,EAAe7C,EAASE,IACzD0I,OAAmB,eAAX7J,EAA0BqJ,EAAcD,EAChDY,cAAezJ,EACf+K,MAAAA,IAER,IACiB,UAAVP,GACPhF,EAAc+G,QAAQV,GAEtBnH,EAAa2H,SAAQ,SAAAjM,GACjByL,EAAIW,OACJX,EAAIY,YAAc1M,EAElB8L,EAAIa,YACJlH,EAAcpF,EAAMyE,QACpBgH,EAAIc,YAAcvM,EAAMuC,MACxBkJ,EAAI/L,UAAYA,EAChB+L,EAAI1E,SAEJ0E,EAAIe,SACR,KACiB,YAAVpC,EACPxJ,EAAQqL,SAAQ,SAAArC,GACZ6C,EAAqBhB,EAAGzK,KACjB4I,EAAM,CACTlJ,KAAMqE,GACNkF,eAAgBxB,EAChByB,gBAAiBxB,EACjBiC,MAAAA,KAER,IACwB,mBAAVP,GACdA,EAAMqB,EAAKlG,GAEnB,IAvD+B,CAwDnC,GAAG,CACCgG,EACAhD,EACAC,EACAC,EACAC,EACAlB,EACAvG,EACAsE,GACAH,EACAzF,EACAD,EACA4E,EACAnB,EACAO,EACArE,EACAO,EACAgB,EACAmE,GACA4F,GACAxJ,IAIAjB,EAAA,SAAA,CACIwM,IAAKnB,EACL9J,MAAO8G,EAAapH,EACpBO,OAAQ8G,EAAcrH,EACtBwL,MAAO,CACHlL,MAAO8G,EACP7G,OAAQ8G,GAEZjJ,KAAMA,EACN,aAAY2I,EACZ,kBAAiBC,EACjB,mBAAkBC,GAG9B,EAEawE,EAA4B,SAAHjJ,GAAA,IAClCgH,EAAKhH,EAALgH,MAAKH,EAAA7G,EACL9D,cAAAA,OAAa,IAAA2K,EAAGtJ,EAAmBrB,cAAa2K,EAAAC,EAAA9G,EAChD9C,QAAAA,OAAO,IAAA4J,EAAGvJ,EAAmBL,QAAO4J,EAAAC,EAAA/G,EACpC7C,aAAAA,OAAY,IAAA4J,EAAGxJ,EAAmBJ,aAAY4J,EAC9CE,EAAajH,EAAbiH,cACGC,EAAUC,EAAAnH,EAAAoH,GAAA,OAEb7K,EAAC8K,EAAS,CAAOnL,cAAAA,EAAegB,QAAAA,EAASC,aAAAA,EAAc6J,MAAAA,EAAOC,cAAAA,EAAanK,SACvEP,EAACkL,EAA8BpK,EAAA,CAAInB,cAAeA,GAAmBgL,KAC7D,ECzKHgC,EAAsC,SAC/C3B,GAAkE,OAElEhL,EAACiL,EAAiB,CAAA1K,SACb,SAAAV,GAAA,IAAG0B,EAAK1B,EAAL0B,MAAOC,EAAM3B,EAAN2B,OAAM,OACbxB,EAAC0M,EAAyB5L,EAAA,CAAIS,MAAOA,EAAOC,OAAQA,GAAYwJ,GAAS,GAE7D"}