{"version":3,"file":"nivo-parallel-coordinates.cjs.js","sources":["../src/ParallelCoordinatesLineTooltip.tsx","../src/defaults.ts","../src/hooks.ts","../src/svg/ParallelCoordinatesLine.tsx","../src/svg/ParallelCoordinates.tsx","../src/canvas/ParallelCoordinatesCanvas.tsx","../src/svg/ResponsiveParallelCoordinates.tsx","../src/canvas/ResponsiveParallelCoordinatesCanvas.tsx"],"sourcesContent":["import { TableTooltip } from '@nivo/tooltip'\nimport { BaseDatum, TooltipProps, DatumGroupKeys } from './types'\n\nexport const ParallelCoordinatesLineTooltip = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    datum,\n    variables,\n}: TooltipProps<Datum, GroupBy>) => {\n    return (\n        <TableTooltip\n            rows={variables.map(variable => [\n                variable.label || variable.id,\n                <strong>{datum.data[variable.value] as number}</strong>, // eslint-disable-line react/jsx-key\n            ])}\n        />\n    )\n}\n","import { CommonProps, BaseDatum, LayerId } from './types'\nimport { ParallelCoordinatesLineTooltip } from './ParallelCoordinatesLineTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonProps<BaseDatum>,\n    | 'groupBy'\n    | 'groups'\n    | 'margin'\n    | 'theme'\n    | 'forwardLegendData'\n    | 'renderWrapper'\n    | 'ariaLabel'\n    | 'ariaLabelledBy'\n    | 'ariaDescribedBy'\n> = {\n    layout: 'horizontal',\n    curve: 'linear',\n\n    role: 'img',\n\n    colors: { scheme: 'category10' },\n    lineWidth: 2,\n    lineOpacity: 0.5,\n\n    axesTicksPosition: 'after',\n\n    isInteractive: true,\n    tooltip: ParallelCoordinatesLineTooltip,\n\n    legends: [],\n\n    animate: true,\n    motionConfig: 'gentle',\n}\n\nexport const svgDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n}\n\nexport const canvasDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1,\n}\n","import { useMemo, useRef, useEffect } from 'react'\nimport { line } from 'd3-shape'\nimport { scaleLinear, scalePoint } from 'd3-scale'\nimport { curveFromProp } from '@nivo/core'\nimport { OrdinalColorScaleConfig, useOrdinalColorScale } from '@nivo/colors'\nimport { castPointScale, castLinearScale, ScalePoint } from '@nivo/scales'\nimport {\n    Variable,\n    VariableWithScale,\n    CommonProps,\n    ComputedDatum,\n    BaseDatum,\n    BaseGroup,\n    Group,\n    CustomLayerProps,\n    GroupLegend,\n    DatumLegend,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from './types'\nimport { commonDefaultProps } from './defaults'\n\n/**\n * Compute groups.\n *\n * Please note that we assume that `groupBy` is defined, and correct, at this stage.\n *\n * If `predefinedGroups` is provided, we'll use it as a base, otherwise\n * we're going to scan each datum and extract their group, and then\n * make those unique to define the available groups.\n */\nconst computeGroups = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    predefinedGroups,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy: DatumGroupKeys<Datum>\n    predefinedGroups?: readonly BaseGroup[]\n    getColor: (group: BaseGroup) => string\n}): Group[] => {\n    let groups: Group[]\n\n    if (predefinedGroups !== undefined) {\n        groups = predefinedGroups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: getColor(group),\n        }))\n    } else {\n        const groupsSet = new Set<string>()\n        for (const datum of data) {\n            groupsSet.add(datum[groupBy] as string)\n        }\n\n        groups = Array.from(groupsSet, groupId => {\n            const group: BaseGroup = {\n                id: groupId,\n                label: groupId,\n            }\n\n            return {\n                ...group,\n                color: getColor(group),\n            }\n        })\n    }\n\n    return groups\n}\n\n/**\n * Compute the scale for each variable.\n *\n * We only support linear scales.\n *\n * Each scale domain will be computed automatically if `min`/`max` = `'auto'`,\n * otherwise, we'll use the provided values.\n */\nconst computeVariablesScales = <Datum extends BaseDatum>({\n    width,\n    height,\n    data,\n    variables,\n    layout,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    layout: CommonProps<Datum>['layout']\n}): readonly VariableWithScale<Datum>[] => {\n    // Depending on the layout, the range might need to be switched.\n    const range = layout === 'horizontal' ? [height, 0] : [0, width]\n\n    return variables.map(variable => {\n        const allValues: number[] = data.map(datum => datum[variable.value] as number)\n\n        const min =\n            variable.min !== undefined && variable.min !== 'auto'\n                ? variable.min\n                : Math.min(...allValues!)\n        const max =\n            variable.max !== undefined && variable.max !== 'auto'\n                ? variable.max\n                : Math.max(...allValues!)\n\n        const scale = castLinearScale(scaleLinear().rangeRound(range).domain([min, max]))\n\n        return { ...variable, scale }\n    })\n}\n\nconst computeDataVariables = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    groups,\n    variablesScale,\n    variablesWithScale,\n    layout,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy?: DatumGroupKeys<Datum>\n    groups: Group[] | undefined\n    variablesScale: ScalePoint<string>\n    variablesWithScale: readonly VariableWithScale<Datum>[]\n    layout: CommonProps<Datum>['layout']\n    getColor: (datum: Datum) => string\n}): ComputedDatum<Datum>[] | ComputedGroupDatum<Datum>[] => {\n    return data.map((datum, index) => {\n        const points: [number, number][] = variablesWithScale.map(variable => [\n            layout === 'horizontal'\n                ? variablesScale(variable.id)!\n                : variable.scale(datum[variable.value] as number),\n            layout === 'horizontal'\n                ? variable.scale(datum[variable.value] as number)\n                : variablesScale(variable.id)!,\n        ])\n\n        let group: Group | undefined = undefined\n        if (groupBy !== undefined) {\n            const datumGroup = datum[groupBy]\n            group = groups?.find(candidateGroup => candidateGroup.id === datumGroup)\n        }\n\n        const computedDatum: ComputedDatum<Datum> = {\n            id: datum.id,\n            index,\n            points,\n            data: datum,\n            color: group ? group.color : getColor(datum),\n        }\n\n        if (!group) return computedDatum\n\n        return {\n            ...computedDatum,\n            group,\n        } as ComputedGroupDatum<Datum>\n    })\n}\n\nexport const useParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    width,\n    height,\n    data,\n    variables,\n    groupBy,\n    groups: predefinedGroups,\n    layout = commonDefaultProps.layout,\n    curve = commonDefaultProps.curve,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<\n        IfGrouped<Datum, GroupBy, BaseGroup, Datum>\n    >,\n    forwardLegendData,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    groupBy?: CommonProps<Datum, GroupBy>['groupBy']\n    groups?: CommonProps<Datum, GroupBy>['groups']\n    layout: CommonProps<Datum, GroupBy>['layout']\n    curve: CommonProps<Datum, GroupBy>['curve']\n    colors: CommonProps<Datum, GroupBy>['colors']\n    forwardLegendData?: CommonProps<Datum, GroupBy>['forwardLegendData']\n}) => {\n    // If no groups, we'll use the data to define the color, otherwise the groups,\n    // meaning that `id` refers to either `Datum.id` or `Group.id`.\n    const getColor = useOrdinalColorScale(colors, 'id')\n\n    const groups = useMemo(() => {\n        if (groupBy === undefined) return undefined\n\n        return computeGroups<Datum>({\n            data,\n            groupBy,\n            predefinedGroups,\n            getColor: getColor as (group: BaseGroup) => string,\n        })\n    }, [data, groupBy, predefinedGroups, getColor])\n\n    const variablesScale = useMemo(() => {\n        const variableIds = variables.map(({ id }) => id)\n        return castPointScale(\n            scalePoint()\n                .range(layout === 'horizontal' ? [0, width] : [height, 0])\n                .domain(variableIds)\n        )\n    }, [variables, layout, width, height])\n\n    const variablesWithScale = useMemo(\n        () =>\n            computeVariablesScales<Datum>({\n                width,\n                height,\n                data,\n                variables,\n                layout,\n            }),\n        [width, height, data, variables, layout]\n    )\n\n    const computedData = useMemo(\n        () =>\n            computeDataVariables<Datum>({\n                data,\n                groupBy,\n                groups,\n                variablesScale,\n                variablesWithScale,\n                layout,\n                getColor,\n            }),\n        [data, groupBy, groups, variablesScale, variablesWithScale, layout, getColor]\n    )\n\n    const legendData = useMemo(() => {\n        if (!groups) {\n            return computedData.map(datum => ({\n                id: datum.id,\n                label: datum.id,\n                color: datum.color,\n                data: datum,\n            })) as DatumLegend<Datum>[]\n        }\n\n        return groups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: group.color,\n            data: group,\n        })) as GroupLegend[]\n    }, [groups, computedData])\n\n    // Forward the legends data if `forwardLegendData` is defined.\n    const forwardLegendDataRef = useRef(forwardLegendData)\n    useEffect(() => {\n        if (typeof forwardLegendDataRef.current !== 'function') return\n        forwardLegendDataRef.current(\n            legendData as IfGrouped<Datum, GroupBy, GroupLegend[], DatumLegend<Datum>[]>\n        )\n    }, [forwardLegendDataRef, legendData])\n\n    const lineGenerator = useMemo(\n        () => line<[number, number]>().curve(curveFromProp(curve)),\n        [curve]\n    )\n\n    const customLayerContext: CustomLayerProps<Datum> = useMemo(\n        () => ({\n            computedData,\n            variables,\n            lineGenerator,\n        }),\n        [computedData, variables, lineGenerator]\n    )\n\n    return {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    }\n}\n","import { useCallback, MouseEvent, createElement } from 'react'\nimport { Line } from 'd3-shape'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport {\n    BaseDatum,\n    ComputedDatum,\n    Variable,\n    TooltipComponent,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from '../types'\n\nexport const ParallelCoordinatesLine = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    datum,\n    variables,\n    lineGenerator,\n    lineWidth,\n    opacity,\n    tooltip,\n    testIdPrefix,\n}: {\n    datum: IfGrouped<Datum, GroupBy, ComputedGroupDatum<Datum>, ComputedDatum<Datum>>\n    variables: readonly Variable<Datum>[]\n    lineGenerator: Line<[number, number]>\n    lineWidth: number\n    opacity: number\n    tooltip: TooltipComponent<Datum, GroupBy>\n    testIdPrefix?: string\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { datum, variables }), event)\n        },\n        [showTooltipFromEvent, datum, variables]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(lineGenerator(datum.points)!)\n    const animatedProps = useSpring({\n        color: datum.color,\n        opacity,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            stroke={animatedProps.color}\n            strokeWidth={lineWidth}\n            strokeLinecap=\"round\"\n            opacity={animatedProps.opacity}\n            fill=\"none\"\n            onMouseEnter={handleMouseHover}\n            onMouseMove={handleMouseHover}\n            onMouseLeave={hideTooltip}\n            data-test-id={testIdPrefix ? `${testIdPrefix}.line_${datum.id}` : undefined}\n        />\n    )\n}\n","import { createElement, Fragment, ReactNode } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { Axis } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { svgDefaultProps } from '../defaults'\nimport { useParallelCoordinates } from '../hooks'\nimport {\n    ParallelCoordinatesProps,\n    BaseDatum,\n    LayerId,\n    DatumGroupKeys,\n    TooltipComponent,\n    IfGrouped,\n    ComputedGroupDatum,\n    ComputedDatum,\n} from '../types'\nimport { ParallelCoordinatesLine } from './ParallelCoordinatesLine'\n\ntype InnerParallelCoordinatesProps<\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n> = Omit<\n    ParallelCoordinatesProps<Datum, GroupBy>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    data,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    layout = svgDefaultProps.layout,\n    curve = svgDefaultProps.curve,\n    axesTicksPosition,\n    lineWidth = svgDefaultProps.lineWidth,\n    lineOpacity = svgDefaultProps.lineOpacity,\n    colors = svgDefaultProps.colors,\n    layers = svgDefaultProps.layers,\n    tooltip = svgDefaultProps.tooltip as unknown as TooltipComponent<Datum, GroupBy>,\n    legends = svgDefaultProps.legends,\n    forwardLegendData,\n    role = svgDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    testIdPrefix,\n}: InnerParallelCoordinatesProps<Datum, GroupBy>) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<Datum, GroupBy>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const layerById: Record<LayerId, ReactNode> = {\n        axes: null,\n        lines: null,\n        legends: null,\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <g key=\"axes\">\n                {variablesWithScale.map(variable => (\n                    <Axis\n                        key={variable.id}\n                        axis={layout === 'horizontal' ? 'y' : 'x'}\n                        length={layout === 'horizontal' ? innerHeight : innerWidth}\n                        x={layout === 'horizontal' ? variablesScale(variable.id) : 0}\n                        y={layout === 'horizontal' ? 0 : variablesScale(variable.id)}\n                        scale={variable.scale}\n                        ticksPosition={variable.ticksPosition || axesTicksPosition}\n                        tickValues={variable.tickValues}\n                        tickSize={variable.tickSize}\n                        tickPadding={variable.tickPadding}\n                        tickRotation={variable.tickRotation}\n                        format={variable.tickFormat}\n                        legend={variable.label || variable.id}\n                        legendPosition={variable.legendPosition}\n                        legendOffset={variable.legendOffset}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <g key=\"lines\">\n                {computedData.map(datum => (\n                    <ParallelCoordinatesLine<Datum, GroupBy>\n                        key={`${'group' in datum ? datum.group.id : ''}${datum.id}`}\n                        datum={\n                            datum as IfGrouped<\n                                Datum,\n                                GroupBy,\n                                ComputedGroupDatum<Datum>,\n                                ComputedDatum<Datum>\n                            >\n                        }\n                        variables={variables}\n                        lineGenerator={lineGenerator}\n                        lineWidth={lineWidth}\n                        opacity={lineOpacity}\n                        tooltip={tooltip}\n                        testIdPrefix={testIdPrefix}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <g key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legendData}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, customLayerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const ParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesProps<Datum, GroupBy>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerParallelCoordinates<Datum, GroupBy> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { useEffect, useRef } from 'react'\nimport { Container, useDimensions, useTheme } from '@nivo/core'\nimport { renderAxisToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useParallelCoordinates } from '../hooks'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { canvasDefaultProps } from '../defaults'\n\ntype InnerParallelCoordinatesCanvasProps<D extends BaseDatum> = Omit<\n    ParallelCoordinatesCanvasProps<D>,\n    'renderWrapper' | 'theme'\n>\n\nexport const InnerParallelCoordinatesCanvas = <D extends BaseDatum>({\n    data,\n    layout = canvasDefaultProps.layout,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    curve = canvasDefaultProps.curve,\n    colors = canvasDefaultProps.colors,\n    lineOpacity = canvasDefaultProps.lineOpacity,\n    lineWidth = canvasDefaultProps.lineWidth,\n    axesTicksPosition = canvasDefaultProps.axesTicksPosition,\n    legends = canvasDefaultProps.legends,\n    forwardLegendData,\n    layers = canvasDefaultProps.layers,\n    role = canvasDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n}: InnerParallelCoordinatesCanvasProps<D>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<D>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const theme = useTheme()\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        const ctx = canvasEl.current.getContext('2d')\n        if (ctx === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (layer === 'axes') {\n                variablesWithScale.forEach(variable => {\n                    renderAxisToCanvas(ctx, {\n                        axis: layout === 'horizontal' ? 'y' : 'x',\n                        scale: variable.scale,\n                        x: layout === 'horizontal' ? variablesScale(variable.id) : 0,\n                        y: layout === 'horizontal' ? 0 : variablesScale(variable.id),\n                        length: layout === 'horizontal' ? innerHeight : innerWidth,\n                        ticksPosition: axesTicksPosition,\n                        theme,\n                    })\n                })\n            } else if (layer === 'lines') {\n                lineGenerator.context(ctx)\n\n                computedData.forEach(datum => {\n                    ctx.save()\n                    ctx.globalAlpha = lineOpacity\n\n                    ctx.beginPath()\n                    lineGenerator(datum.points)\n                    ctx.strokeStyle = datum.color\n                    ctx.lineWidth = lineWidth\n                    ctx.stroke()\n\n                    ctx.restore()\n                })\n            } else if (layer === 'legends') {\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            } else if (typeof layer === 'function') {\n                layer(ctx, customLayerContext)\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        innerWidth,\n        innerHeight,\n        margin,\n        layers,\n        customLayerContext,\n        lineGenerator,\n        lineOpacity,\n        lineWidth,\n        computedData,\n        variablesScale,\n        variablesWithScale,\n        layout,\n        axesTicksPosition,\n        legends,\n        legendData,\n        theme,\n        pixelRatio,\n    ])\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n            }}\n            role={role}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledBy}\n            aria-describedby={ariaDescribedBy}\n        />\n    )\n}\n\nexport const ParallelCoordinatesCanvas = <D extends BaseDatum>({\n    theme,\n    isInteractive = canvasDefaultProps.isInteractive,\n    animate = canvasDefaultProps.animate,\n    motionConfig = canvasDefaultProps.motionConfig,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesCanvasProps<D>) => (\n    <Container {...{ isInteractive, animate, motionConfig, theme, renderWrapper }}>\n        <InnerParallelCoordinatesCanvas<D> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { ParallelCoordinatesProps, BaseDatum, DatumGroupKeys } from '../types'\nimport { ParallelCoordinates } from './ParallelCoordinates'\n\nexport const ResponsiveParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>(\n    props: Omit<ParallelCoordinatesProps<Datum, GroupBy>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinates<Datum, GroupBy> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { ParallelCoordinatesCanvas } from './ParallelCoordinatesCanvas'\n\nexport const ResponsiveParallelCoordinatesCanvas = <D extends BaseDatum>(\n    props: Omit<ParallelCoordinatesCanvasProps<D>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinatesCanvas<D> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n"],"names":["commonDefaultProps","layout","curve","role","colors","scheme","lineWidth","lineOpacity","axesTicksPosition","isInteractive","tooltip","_ref","datum","variables","_jsx","TableTooltip","rows","map","variable","label","id","jsx","children","data","value","legends","animate","motionConfig","svgDefaultProps","_extends","layers","canvasDefaultProps","pixelRatio","window","_window$devicePixelRa","devicePixelRatio","useParallelCoordinates","_ref4","width","height","groupBy","predefinedGroups","groups","_ref4$layout","_ref4$curve","_ref4$colors","forwardLegendData","getColor","useOrdinalColorScale","useMemo","undefined","group","color","_step","groupsSet","Set","_iterator","_createForOfIteratorHelperLoose","done","add","Array","from","groupId","computeGroups","variablesScale","variableIds","_ref5","castPointScale","scalePoint","range","domain","variablesWithScale","_ref2","allValues","min","Math","apply","max","scale","castLinearScale","scaleLinear","rangeRound","computeVariablesScales","computedData","_ref3","index","points","datumGroup","find","candidateGroup","computedDatum","computeDataVariables","legendData","forwardLegendDataRef","useRef","useEffect","current","lineGenerator","line","curveFromProp","customLayerContext","ParallelCoordinatesLine","opacity","testIdPrefix","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseHover","useCallback","event","createElement","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","path","d","stroke","strokeWidth","strokeLinecap","fill","onMouseEnter","onMouseMove","onMouseLeave","InnerParallelCoordinates","partialMargin","margin","_ref$layout","_ref$curve","_ref$lineWidth","_ref$lineOpacity","_ref$colors","_ref$layers","_ref$tooltip","_ref$legends","_ref$role","ariaLabel","ariaLabelledBy","ariaDescribedBy","_useDimensions","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","_useParallelCoordinat","layerById","axes","lines","includes","Axis","axis","length","x","y","ticksPosition","tickValues","tickSize","tickPadding","tickRotation","format","tickFormat","legend","legendPosition","legendOffset","i","BoxLegendSvg","containerWidth","containerHeight","SvgWrapper","layer","_layerById$layer","Fragment","ParallelCoordinates","_ref2$isInteractive","_ref2$animate","_ref2$motionConfig","theme","renderWrapper","otherProps","_objectWithoutPropertiesLoose","_excluded","Container","InnerParallelCoordinatesCanvas","_ref$axesTicksPositio","_ref$pixelRatio","canvasEl","useTheme","ctx","getContext","fillStyle","background","fillRect","translate","left","top","forEach","renderAxisToCanvas","context","save","globalAlpha","beginPath","strokeStyle","restore","renderLegendToCanvas","ref","style","ParallelCoordinatesCanvas","props","ResponsiveWrapper"],"mappings":"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"}