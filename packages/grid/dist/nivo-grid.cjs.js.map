{"version":3,"file":"nivo-grid.cjs.js","sources":["../src/boundingBoxes.ts","../src/grid.ts","../src/polygon.ts"],"sourcesContent":["import { BoundingBox } from './types'\n\n/**\n * Check if the provided bounding boxes touch/overlap.\n * We assume that the boxes are rectangular and axis-aligned.\n */\nexport const areBoundingBoxTouching = (boxA: BoundingBox, boxB: BoundingBox) => {\n    const touchX = boxA.left <= boxB.right && boxB.left <= boxA.right\n    const touchY = boxA.top <= boxB.bottom && boxB.top <= boxA.bottom\n\n    return touchX && touchY\n}\n","import { GridFillDirection, GridCell, Vertex } from './types'\n\nexport const computeCellDimensions = ({\n    width,\n    height,\n    rows,\n    columns,\n    padding,\n    square,\n}: {\n    width: number\n    height: number\n    rows: number\n    columns: number\n    padding: number\n    square: boolean\n}) => {\n    const cellWidth = (width - (columns - 1) * padding) / columns\n    const cellHeight = (height - (rows - 1) * padding) / rows\n\n    if (!square) return [cellWidth, cellHeight]\n\n    const min = Math.min(cellWidth, cellHeight)\n    return [min, min]\n}\n\n/**\n * Generate a grid of cells.\n */\nexport const generateGrid = <C extends GridCell = GridCell>({\n    width,\n    height,\n    columns,\n    rows,\n    padding = 0,\n    fillDirection = 'bottom',\n    square = true,\n    extend,\n}: {\n    width: number\n    height: number\n    columns: number\n    rows: number\n    padding?: number\n    fillDirection?: GridFillDirection\n    square?: boolean\n    extend?: (cell: GridCell, origin: [number, number]) => C\n}) => {\n    const [cellWidth, cellHeight] = computeCellDimensions({\n        width,\n        height,\n        rows,\n        columns,\n        padding,\n        square,\n    })\n\n    const origin: Vertex = [\n        (width - (cellWidth * columns + padding * (columns - 1))) / 2,\n        (height - (cellHeight * rows + padding * (rows - 1))) / 2,\n    ]\n\n    const cells: GridCell[] = []\n\n    for (let row = 0; row < rows; row++) {\n        for (let column = 0; column < columns; column++) {\n            const x = column * cellWidth\n            const y = row * cellHeight\n            const key = `${row}.${column}`\n\n            cells.push({\n                key,\n                // Adjusted later depending on `fillDirection`.\n                index: 0,\n                column,\n                row,\n                x,\n                y,\n                width: cellWidth,\n                height: cellHeight,\n            })\n        }\n    }\n\n    switch (fillDirection) {\n        case 'left':\n            cells.sort((a, b) => {\n                if (a.column !== b.column) {\n                    return b.column - a.column\n                }\n                return b.row - a.row\n            })\n            break\n        case 'top':\n            cells.sort((a, b) => {\n                if (a.row !== b.row) {\n                    return b.row - a.row\n                }\n                return b.column - a.column\n            })\n            break\n        case 'right':\n            cells.sort((a, b) => {\n                if (a.column !== b.column) {\n                    return a.column - b.column\n                }\n                return a.row - b.row\n            })\n            break\n\n        default: // bottom, nothing to do.\n    }\n\n    // Adjust the index depending on `fillDirection`.\n    cells.forEach((cell, index) => {\n        cell.index = index\n    })\n\n    // Optionally \"augment\" the cells via `extend`.\n    const extendedCells: C[] =\n        typeof extend === 'function' ? cells.map(cell => extend(cell, origin)) : (cells as C[])\n\n    return {\n        x: origin[0],\n        y: origin[1],\n        cellWidth,\n        cellHeight,\n        cells: extendedCells,\n    }\n}\n","import { Vertex, BoundingBox, GridCell } from './types'\nimport { areBoundingBoxTouching } from './boundingBoxes'\n\n/**\n * A perpendicular polygon defined by left/right vertices.\n *\n * We split left/right vertices so that it's possible to generate\n * a path by traversing the right vertices and then the left ones.\n * This traversal is clockwise, meaning that right vertices are\n * sorted by y ascending, while left vertices are sorted by y descending.\n *\n * Please note that we don't close the polygon, the first vertex\n * is going to be the first right vertex, and the last one is going\n * to be the last left vertex, in order to close the polygon,\n * you could for example use `d3.line` with a `linearClosed` curve.\n */\nexport function perpendicularPolygon() {\n    const left: Vertex[] = []\n    const right: Vertex[] = []\n\n    function polygon() {\n        return [...right, ...left]\n    }\n\n    polygon.addRight = (...vertices: Vertex[]) => {\n        right.push(...vertices)\n    }\n\n    polygon.addLeft = (...vertices: Vertex[]) => {\n        left.unshift(...vertices)\n    }\n\n    polygon.debug = () => {\n        return { right, left }\n    }\n\n    return polygon\n}\n\nexport const getCellsPolygons = <C extends GridCell>(cells: C[]) => {\n    // 1. Sort cells by x and y coordinates.\n    const sortedCells = [...cells].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y\n        return a.x - b.x\n    })\n\n    // 2. Compute a box for each row.\n    const rows: BoundingBox[] = []\n    let currentBox: BoundingBox | undefined = undefined\n    for (const cell of sortedCells) {\n        if (currentBox === undefined || cell.y !== currentBox.top) {\n            currentBox = {\n                top: cell.y,\n                right: cell.x + cell.width,\n                bottom: cell.y + cell.height,\n                left: cell.x,\n            }\n            rows.push(currentBox)\n        } else {\n            currentBox.right = cell.x + cell.width\n        }\n    }\n\n    // 3. Compute polygons for each group of adjacent rows.\n    const polygons: ReturnType<typeof perpendicularPolygon>[] = []\n    let currentPolygon: ReturnType<typeof perpendicularPolygon> | undefined = undefined\n    rows.forEach((row, index) => {\n        const previousBox: BoundingBox | undefined = index > 0 ? rows[index - 1] : undefined\n        if (previousBox === undefined || !areBoundingBoxTouching(row, previousBox)) {\n            currentPolygon = perpendicularPolygon()\n            currentPolygon.addLeft([row.left, row.top])\n            currentPolygon.addRight([row.right, row.top])\n\n            polygons.push(currentPolygon)\n        }\n\n        if (previousBox !== undefined && row.left !== previousBox.left) {\n            currentPolygon!.addLeft([row.left, row.top])\n        }\n        if (previousBox !== undefined && row.right !== previousBox.right) {\n            currentPolygon!.addRight([row.right, row.top])\n        }\n\n        currentPolygon!.addLeft([row.left, row.bottom])\n        currentPolygon!.addRight([row.right, row.bottom])\n    })\n\n    return polygons.map(polygon => polygon())\n}\n"],"names":["areBoundingBoxTouching","boxA","boxB","touchX","left","right","touchY","top","bottom","computeCellDimensions","_ref","width","height","rows","columns","padding","cellWidth","cellHeight","square","min","Math","perpendicularPolygon","polygon","concat","addRight","push","apply","arguments","addLeft","unshift","debug","_ref2","_ref2$padding","_ref2$fillDirection","fillDirection","_ref2$square","extend","_computeCellDimension","origin","cells","row","column","x","y","key","index","sort","a","b","forEach","cell","extendedCells","map","_step","sortedCells","currentBox","undefined","_iterator","_createForOfIteratorHelperLoose","done","value","polygons","currentPolygon","previousBox"],"mappings":"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"}