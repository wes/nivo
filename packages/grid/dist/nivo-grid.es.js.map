{"version":3,"file":"nivo-grid.es.js","sources":["../src/boundingBoxes.ts","../src/grid.ts","../src/polygon.ts"],"sourcesContent":["import { BoundingBox } from './types'\n\n/**\n * Check if the provided bounding boxes touch/overlap.\n * We assume that the boxes are rectangular and axis-aligned.\n */\nexport const areBoundingBoxTouching = (boxA: BoundingBox, boxB: BoundingBox) => {\n    const touchX = boxA.left <= boxB.right && boxB.left <= boxA.right\n    const touchY = boxA.top <= boxB.bottom && boxB.top <= boxA.bottom\n\n    return touchX && touchY\n}\n","import { GridFillDirection, GridCell, Vertex } from './types'\n\nexport const computeCellDimensions = ({\n    width,\n    height,\n    rows,\n    columns,\n    padding,\n    square,\n}: {\n    width: number\n    height: number\n    rows: number\n    columns: number\n    padding: number\n    square: boolean\n}) => {\n    const cellWidth = (width - (columns - 1) * padding) / columns\n    const cellHeight = (height - (rows - 1) * padding) / rows\n\n    if (!square) return [cellWidth, cellHeight]\n\n    const min = Math.min(cellWidth, cellHeight)\n    return [min, min]\n}\n\n/**\n * Generate a grid of cells.\n */\nexport const generateGrid = <C extends GridCell = GridCell>({\n    width,\n    height,\n    columns,\n    rows,\n    padding = 0,\n    fillDirection = 'bottom',\n    square = true,\n    extend,\n}: {\n    width: number\n    height: number\n    columns: number\n    rows: number\n    padding?: number\n    fillDirection?: GridFillDirection\n    square?: boolean\n    extend?: (cell: GridCell, origin: [number, number]) => C\n}) => {\n    const [cellWidth, cellHeight] = computeCellDimensions({\n        width,\n        height,\n        rows,\n        columns,\n        padding,\n        square,\n    })\n\n    const origin: Vertex = [\n        (width - (cellWidth * columns + padding * (columns - 1))) / 2,\n        (height - (cellHeight * rows + padding * (rows - 1))) / 2,\n    ]\n\n    const cells: GridCell[] = []\n\n    for (let row = 0; row < rows; row++) {\n        for (let column = 0; column < columns; column++) {\n            const x = column * cellWidth\n            const y = row * cellHeight\n            const key = `${row}.${column}`\n\n            cells.push({\n                key,\n                // Adjusted later depending on `fillDirection`.\n                index: 0,\n                column,\n                row,\n                x,\n                y,\n                width: cellWidth,\n                height: cellHeight,\n            })\n        }\n    }\n\n    switch (fillDirection) {\n        case 'left':\n            cells.sort((a, b) => {\n                if (a.column !== b.column) {\n                    return b.column - a.column\n                }\n                return b.row - a.row\n            })\n            break\n        case 'top':\n            cells.sort((a, b) => {\n                if (a.row !== b.row) {\n                    return b.row - a.row\n                }\n                return b.column - a.column\n            })\n            break\n        case 'right':\n            cells.sort((a, b) => {\n                if (a.column !== b.column) {\n                    return a.column - b.column\n                }\n                return a.row - b.row\n            })\n            break\n\n        default: // bottom, nothing to do.\n    }\n\n    // Adjust the index depending on `fillDirection`.\n    cells.forEach((cell, index) => {\n        cell.index = index\n    })\n\n    // Optionally \"augment\" the cells via `extend`.\n    const extendedCells: C[] =\n        typeof extend === 'function' ? cells.map(cell => extend(cell, origin)) : (cells as C[])\n\n    return {\n        x: origin[0],\n        y: origin[1],\n        cellWidth,\n        cellHeight,\n        cells: extendedCells,\n    }\n}\n","import { Vertex, BoundingBox, GridCell } from './types'\nimport { areBoundingBoxTouching } from './boundingBoxes'\n\n/**\n * A perpendicular polygon defined by left/right vertices.\n *\n * We split left/right vertices so that it's possible to generate\n * a path by traversing the right vertices and then the left ones.\n * This traversal is clockwise, meaning that right vertices are\n * sorted by y ascending, while left vertices are sorted by y descending.\n *\n * Please note that we don't close the polygon, the first vertex\n * is going to be the first right vertex, and the last one is going\n * to be the last left vertex, in order to close the polygon,\n * you could for example use `d3.line` with a `linearClosed` curve.\n */\nexport function perpendicularPolygon() {\n    const left: Vertex[] = []\n    const right: Vertex[] = []\n\n    function polygon() {\n        return [...right, ...left]\n    }\n\n    polygon.addRight = (...vertices: Vertex[]) => {\n        right.push(...vertices)\n    }\n\n    polygon.addLeft = (...vertices: Vertex[]) => {\n        left.unshift(...vertices)\n    }\n\n    polygon.debug = () => {\n        return { right, left }\n    }\n\n    return polygon\n}\n\nexport const getCellsPolygons = <C extends GridCell>(cells: C[]) => {\n    // 1. Sort cells by x and y coordinates.\n    const sortedCells = [...cells].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y\n        return a.x - b.x\n    })\n\n    // 2. Compute a box for each row.\n    const rows: BoundingBox[] = []\n    let currentBox: BoundingBox | undefined = undefined\n    for (const cell of sortedCells) {\n        if (currentBox === undefined || cell.y !== currentBox.top) {\n            currentBox = {\n                top: cell.y,\n                right: cell.x + cell.width,\n                bottom: cell.y + cell.height,\n                left: cell.x,\n            }\n            rows.push(currentBox)\n        } else {\n            currentBox.right = cell.x + cell.width\n        }\n    }\n\n    // 3. Compute polygons for each group of adjacent rows.\n    const polygons: ReturnType<typeof perpendicularPolygon>[] = []\n    let currentPolygon: ReturnType<typeof perpendicularPolygon> | undefined = undefined\n    rows.forEach((row, index) => {\n        const previousBox: BoundingBox | undefined = index > 0 ? rows[index - 1] : undefined\n        if (previousBox === undefined || !areBoundingBoxTouching(row, previousBox)) {\n            currentPolygon = perpendicularPolygon()\n            currentPolygon.addLeft([row.left, row.top])\n            currentPolygon.addRight([row.right, row.top])\n\n            polygons.push(currentPolygon)\n        }\n\n        if (previousBox !== undefined && row.left !== previousBox.left) {\n            currentPolygon!.addLeft([row.left, row.top])\n        }\n        if (previousBox !== undefined && row.right !== previousBox.right) {\n            currentPolygon!.addRight([row.right, row.top])\n        }\n\n        currentPolygon!.addLeft([row.left, row.bottom])\n        currentPolygon!.addRight([row.right, row.bottom])\n    })\n\n    return polygons.map(polygon => polygon())\n}\n"],"names":["areBoundingBoxTouching","boxA","boxB","touchX","left","right","touchY","top","bottom","computeCellDimensions","_ref","width","height","rows","columns","padding","cellWidth","cellHeight","square","min","Math","generateGrid","_ref2","_ref2$padding","_ref2$fillDirection","fillDirection","_ref2$square","extend","_computeCellDimension","origin","cells","row","column","x","y","key","push","index","sort","a","b","forEach","cell","extendedCells","map","perpendicularPolygon","polygon","concat","addRight","apply","arguments","addLeft","unshift","debug","getCellsPolygons","_step","sortedCells","currentBox","undefined","_iterator","_createForOfIteratorHelperLoose","done","value","polygons","currentPolygon","previousBox"],"mappings":"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"}